package com.gitdb;

import java.sql.*;
import java.util.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.io.*;

public class GitDBStatement implements Statement {
    private final GitDBConnection connection;
    private GitDBResultSet currentResultSet;
    private int updateCount = -1;
    private final List<String> batch = new ArrayList<>();
    private int maxRows = 0;
    private int queryTimeout = 0;

    public GitDBStatement(GitDBConnection connection) {
        this.connection = connection;
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        try {
            URL url = new URL(connection.getEndpoint() + "/sql");
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json");
            conn.setRequestProperty("Session-ID", connection.getSessionId());
            conn.setDoOutput(true);

            String json = "{\"sql\": \"" + sql.replace("\"", "\\\"") + "\"}";
            try (OutputStream os = conn.getOutputStream()) {
                os.write(json.getBytes());
                os.flush();
            }

            BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = in.readLine()) != null) {
                response.append(line);
            }
            in.close();

            String resp = response.toString().trim();
            if (resp.startsWith("[")) {
                List<Map<String, Object>> rows = GitDBResultSet.parseJson(resp);
                currentResultSet = new GitDBResultSet(rows);
                updateCount = -1;
                return true;
            } else if (resp.startsWith("{")) {
                Map<String, Object> result = GitDBResultSet.parseJsonObject(resp);
                updateCount = "ok".equals(result.get("status")) ? 1 : 0;
                currentResultSet = null;
                return false;
            } else {
                throw new SQLException("Unexpected response from server: " + resp);
            }
        } catch (Exception e) {
            throw new SQLException("Error executing SQL", e);
        }
    }

    @Override public ResultSet executeQuery(String sql) throws SQLException {
        if (!execute(sql)) throw new SQLException("Query did not return a ResultSet");
        return currentResultSet;
    }

    @Override public int executeUpdate(String sql) throws SQLException {
        execute(sql);
        return updateCount;
    }

    @Override public void addBatch(String sql) {
        batch.add(sql);
    }

    @Override public void clearBatch() {
        batch.clear();
    }

    @Override public int[] executeBatch() throws SQLException {
        int[] results = new int[batch.size()];
        for (int i = 0; i < batch.size(); i++) {
            results[i] = executeUpdate(batch.get(i));
        }
        batch.clear();
        return results;
    }

    @Override public int getUpdateCount() {
        return updateCount;
    }

    @Override public ResultSet getResultSet() {
        return currentResultSet;
    }

    @Override public void close() {}

    @Override public Connection getConnection() {
        return connection;
    }

    @Override public boolean getMoreResults() {
        return false;
    }

    @Override public boolean getMoreResults(int current) {
        return false;
    }

    @Override public ResultSet getGeneratedKeys() throws SQLException {
        return new GitDBResultSet(Collections.emptyList());
    }

    @Override public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql);
    }

    @Override public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql);
    }

    @Override public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql);
    }

    @Override public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return execute(sql);
    }

    @Override public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return execute(sql);
    }

    @Override public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql);
    }

    @Override public int getMaxFieldSize() {
        return 0;
    }

    @Override public void setMaxFieldSize(int max) {}

    @Override public int getMaxRows() {
        return maxRows;
    }

    @Override public void setMaxRows(int max) {
        this.maxRows = max;
    }

    @Override public void setEscapeProcessing(boolean enable) {}

    @Override public int getQueryTimeout() {
        return queryTimeout;
    }

    @Override public void setQueryTimeout(int seconds) {
        this.queryTimeout = seconds;
    }

    @Override public SQLWarning getWarnings() {
        return null;
    }

    @Override public void clearWarnings() {}

    @Override public void setCursorName(String name) {}

    @Override public void setFetchDirection(int direction) {}

    @Override public int getFetchDirection() {
        return ResultSet.FETCH_FORWARD;
    }

    @Override public void setFetchSize(int rows) {}

    @Override public int getFetchSize() {
        return 0;
    }

    @Override public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override public void cancel() {}

    @Override public boolean isClosed() {
        return false;
    }

    @Override public void setPoolable(boolean poolable) {}

    @Override public boolean isPoolable() {
        return false;
    }

    @Override public void closeOnCompletion() {}

    @Override public boolean isCloseOnCompletion() {
        return false;
    }

    @Override public int getResultSetHoldability() {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }

    @Override public <T> T unwrap(Class<T> iface) {
        return null;
    }

    @Override public boolean isWrapperFor(Class<?> iface) {
        return false;
    }
}
